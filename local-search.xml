<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Workers and Pages搭建各种项目（更新中》》》）</title>
    <link href="/2024/06/15/CF%20Worker%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E9%A1%B9%E7%9B%AE/"/>
    <url>/2024/06/15/CF%20Worker%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天依旧更新一下关于我们赛博大善人的教程。</p><p>首先，Workers是Cloud flare免费提供的一项无服务器部署JavaScript代码到CF的边缘网络上的技术，免费版每天限制100k个请求（10万个），应该是够用了。</p><h4 id="准备步骤：一枚CF和Github账号，一个能绑定在CF的域名，一个聪明的大脑，还有你勤劳的小手"><a href="#准备步骤：一枚CF和Github账号，一个能绑定在CF的域名，一个聪明的大脑，还有你勤劳的小手" class="headerlink" title="准备步骤：一枚CF和Github账号，一个能绑定在CF的域名，一个聪明的大脑，还有你勤劳的小手"></a>准备步骤：一枚CF和Github账号，一个能绑定在CF的域名，一个聪明的大脑，还有你勤劳的小手</h4><h5 id="一-使用CF-Pages搭建Vless节点"><a href="#一-使用CF-Pages搭建Vless节点" class="headerlink" title="一.使用CF Pages搭建Vless节点"></a>一.使用CF Pages搭建Vless节点</h5><p>1.登录进CF仪表盘后，右上角Language更改语言为简体中文后点击右侧的“Workers and Pages”，点击创建</p><p>2选Pages，上传资产</p><p>3.命名一下，创建项目，把这个包传上去，上传完成后点击部署站点，<a href="https://tutt.lanzouh.com/iNuzw227k25e">https://tutt.lanzouh.com/iNuzw227k25e</a>　　无密码</p><p>4.点击自定义域，设置一下域名，点击设置，环境变量，在制作那里添加变量</p><p>5.变量名称为UUID（大写），值的话可以在这个网站里生成：<a href="https://1024tools.com/uuid">https://1024tools.com/uuid</a><br>默认生成了5个随便找一个复制就好，填进去，保存</p><p>6.点击部署，创建新部署，再把那个文件重新传一次就好</p><p>7.点击你刚才给Worker绑定的域名，加上&#x2F;你设置的UUID即可，复制节点配置，添加到V2rayNG里，右键编辑服务器，<br>地址可以替换，我这里贴两个：<a href="http://www.gov.se,www.visa.com.sg,198.41.221.170,端口为443即可/">www.gov.se，www.visa.com.sg，198.41.221.170，端口为443即可</a></p><h5 id="二-使用Cloudflare和Telegraph搭建图床"><a href="#二-使用Cloudflare和Telegraph搭建图床" class="headerlink" title="二.使用Cloudflare和Telegraph搭建图床"></a>二.使用Cloudflare和Telegraph搭建图床</h5><p>1.Fork Telegraph-Image 仓库<br>访问 Telegraph-Image 仓库地址（<a href="https://github.com/cf-pages/Telegraph-Image%EF%BC%89%EF%BC%8Cfork">https://github.com/cf-pages/Telegraph-Image），fork</a> 到个人仓库：</p><p>2.同样点击右侧的“Workers and Pages”，点击创建，选Pages，连接到Git，绑定账号后选择相应仓库开始安装</p><p>3.安装完成后同样点击自定义域，设置一下域名，绑定好以后就可以用这个地址访问了，可以测试一下图片上传</p><p>4.配置高级点的功能<br>4-1.开启图片管理后台<br>Telegraph-Image 的图片管理功能默认是关闭的，我们需要绑定 KV 命名空间才能使用。</p><p>首先，依次点击 Workers 和 Pages ， KV ， 创建命名空间，添加一个名为image-hosting的命名空间</p><p>然后，依次点击 Workers 和 Pages，你刚才创建的那个Pages，设置，函数，绑定刚刚创建的命名空间image-hosting<br>变量名称设置为img_url，KV 命名空间设置为image-hosting，回到部署页面重试部署即可</p><p>4-2.后台登录验证：<br>要开启它，需要新增BASIC_USER（管理员登录名称）和BASIC_PASS（登录密码）环境变量，在你自定义的域名后面加上&#x2F;admin即可访问。</p><h5 id="三-使用Workers搭建Google镜像站"><a href="#三-使用Workers搭建Google镜像站" class="headerlink" title="三.使用Workers搭建Google镜像站"></a>三.使用Workers搭建Google镜像站</h5><p>1.点击Workers和Pagers，创建，选Worker，创建一个Worker，命名一下，点击部署</p><p>２.部署完成后点击编辑代码，删掉原来的代码，粘贴下面的：<br>&#x2F;&#x2F; 反代目标网站<br>const upstream &#x3D; ‘ipv6.google.com.hk’<br>const upstream_v4 &#x3D; ‘<a href="http://www.google.com.hk/">www.google.com.hk</a>‘</p><p>&#x2F;&#x2F; 访问区域黑名单（按需设置）.<br>const blocked_region &#x3D; [‘TK’]</p><p>&#x2F;&#x2F;资源重定向<br>const replace_dict &#x3D; {<br>  $upstream: ‘$custom_domain’,<br>  ‘<a href="http://www.google.com/">www.google.com/</a>‘: ‘ｔｕ．ｔｕｊｉ．ｃｌｏｕｄｎｓ．ｂｅ&#x2F;‘, &#x2F;&#x2F;填入你的子域名（你之后要自定义的那个域名，不是CF默认的）<br>  ‘gstatic.com’: ‘gstatic.cn’,<br>  ‘ajax.googleapis.com’: ‘ajax.lug.ustc.edu.cn’,<br>  ‘fonts.googleapis.com’: ‘fonts.googleapis.cn’,<br>  ‘themes.googleusercontent.com’: ‘google-themes.lug.ustc.edu.cn’,<br>  ‘<a href="http://www.gravatar.com/avatar">www.gravatar.com/avatar</a>‘: ‘dn-qiniu-avatar.qbox.me&#x2F;avatar’,<br>  ‘<a href="http://www.google.co.jp/">www.google.co.jp</a>‘: ‘$custom_domain’,<br>  ‘<a href="http://www.google.com.sg/">www.google.com.sg</a>‘: ‘$custom_domain’,<br>  ‘books.google.com.hk’: ‘$custom_domain’,<br>  ‘books.google.co.jp’: ‘$custom_domain’,<br>  ‘books.google.com.sg’: ‘$custom_domain’,<br>  ‘maps.google.com.hk’: ‘$custom_domain’,<br>  ‘maps.google.co.jp’: ‘$custom_domain’,<br>  ‘maps.google.com.sg’: ‘$custom_domain’,<br>  ‘maps.google.com’: ‘$custom_domain’,<br>  ‘books.google.com’: ‘$custom_domain’,<br>}</p><p>addEventListener(‘fetch’, (event) &#x3D;&gt; {<br>  event.respondWith(fetchAndApply(event.request))<br>})</p><p>async function fetchAndApply(request) {<br>  const region &#x3D; request.headers.get(‘cf-ipcountry’).toUpperCase()<br>&#x2F;&#x2F;   const ip_address &#x3D; request.headers.get(‘cf-connecting-ip’)<br>&#x2F;&#x2F;   const user_agent &#x3D; request.headers.get(‘user-agent’)</p><p>  let response &#x3D; null<br>  let url &#x3D; new URL(request.url)<br>  let url_host &#x3D; url.host</p><p>  if (url.protocol &#x3D;&#x3D; ‘http:’) {<br>    url.protocol &#x3D; ‘https:’<br>    response &#x3D; Response.redirect(url.href)<br>    return response<br>  }</p><p>  &#x2F;&#x2F;检查是否为图片搜索<br>  var key &#x3D; url.href<br>  var ikey1 &#x3D; ‘tbm&#x3D;isch’<br>  var ikey2 &#x3D; ‘&#x2F;img’<br>  if ((key.search(ikey1) &#x3D;&#x3D; -1) &amp;&amp; (key.search(ikey2) &#x3D;&#x3D; -1)) {<br>    var upstream_domain &#x3D; upstream<br>  } else {<br>    var upstream_domain &#x3D; upstream_v4<br>  }</p><p>  url.host &#x3D; upstream_domain</p><p>  if (blocked_region.includes(region)) {<br>    response &#x3D; new Response(<br>      ‘Access denied: WorkersProxy is not available in your region yet.’,<br>      {<br>        status: 403,<br>      }<br>    )<br>  } else {<br>    let method &#x3D; request.method<br>    let request_headers &#x3D; request.headers<br>    let new_request_headers &#x3D; new Headers(request_headers)</p><pre><code class="hljs">new_request_headers.set(&#39;Host&#39;, upstream_domain)new_request_headers.set(&#39;Referer&#39;, url.href)let original_response = await fetch(url.href, &#123;  method: method,  headers: new_request_headers,&#125;)let original_response_clone = original_response.clone()let original_text = nulllet response_headers = original_response.headerslet new_response_headers = new Headers(response_headers)let status = original_response.statusnew_response_headers.set(&#39;cache-control&#39;, &#39;public, max-age=14400&#39;)new_response_headers.set(&#39;access-control-allow-origin&#39;, &#39;*&#39;)new_response_headers.set(&#39;access-control-allow-credentials&#39;, true)new_response_headers.delete(&#39;content-security-policy&#39;)new_response_headers.delete(&#39;content-security-policy-report-only&#39;)new_response_headers.delete(&#39;clear-site-data&#39;)const content_type = new_response_headers.get(&#39;content-type&#39;)if (content_type.includes(&#39;text/html&#39;) &amp;&amp; content_type.includes(&#39;UTF-8&#39;)) &#123;  // &amp;&amp; content_type.includes(&#39;UTF-8&#39;)  original_text = await replace_response_text(    original_response_clone,    upstream_domain,    url_host  )&#125; else &#123;  original_text = original_response_clone.body&#125;response = new Response(original_text, &#123;  status,  headers: new_response_headers,&#125;)</code></pre><p>  }<br>  return response<br>}</p><p>async function replace_response_text(response, upstream_domain, host_name) {<br>  let text &#x3D; await response.text()</p><p>  var i, j<br>  for (i in replace_dict) {<br>    j &#x3D; replace_dict[i]<br>    if (i &#x3D;&#x3D; ‘$upstream’) {<br>      i &#x3D; upstream_domain<br>    } else if (i &#x3D;&#x3D; ‘$custom_domain’) {<br>      i &#x3D; host_name<br>    }</p><pre><code class="hljs">if (j == &#39;$upstream&#39;) &#123;  j = upstream_domain&#125; else if (j == &#39;$custom_domain&#39;) &#123;  j = host_name&#125;let re = new RegExp(i, &#39;g&#39;)text = text.replace(re, j)</code></pre><p>  }</p><p>  return text<br>}</p><p>注意：记得把 ‘<a href="http://www.google.com/">www.google.com/</a>‘: ‘ｔｕ．ｔｕｊｉ．ｃｌｏｕｄｎｓ．ｂｅ&#x2F;‘, 此处的ｔｕ．ｔｕｊｉ．ｃｌｏｕｄｎｓ．ｂｅ替换为你的子域名（你之后要自定义的那个域名，不是CF默认的）</p><p>３.回到设置，触发器，绑定自定义域名，，等待DNS解析生效后即可访问</p><h5 id="四．使用Workers镜像Github"><a href="#四．使用Workers镜像Github" class="headerlink" title="四．使用Workers镜像Github"></a>四．使用Workers镜像Github</h5><p>1.点击Workers和Pagers，创建，选Worker，创建一个Worker，命名一下，点击部署</p><p>２.部署完成后点击编辑代码，删掉原来的代码，粘贴下面的：<br>&#x2F;&#x2F; 你要镜像的网站.<br>const upstream &#x3D; ‘github.com’</p><p>&#x2F;&#x2F; 镜像网站的目录，比如你想镜像某个网站的二级目录则填写二级目录的目录名，镜像 google 用不到，默认即可.<br>const upstream_path &#x3D; ‘&#x2F;‘</p><p>&#x2F;&#x2F; 镜像站是否有手机访问专用网址，没有则填一样的.<br>const upstream_mobile &#x3D; ‘github.com’</p><p>&#x2F;&#x2F; 屏蔽国家和地区.<br>const blocked_region &#x3D; [‘KP’, ‘SY’, ‘PK’, ‘CU’]</p><p>&#x2F;&#x2F; 屏蔽 IP 地址.<br>const blocked_ip_address &#x3D; [‘0.0.0.0’, ‘127.0.0.1’]</p><p>&#x2F;&#x2F; 镜像站是否开启 HTTPS.<br>const https &#x3D; true</p><p>&#x2F;&#x2F; 文本替换.<br>const replace_dict &#x3D; {‘$upstream’: ‘$custom_domain’, ‘&#x2F;&#x2F;github.com’: ‘’}</p><p>&#x2F;&#x2F; 以下保持默认，不要动<br>addEventListener(‘fetch’, event &#x3D;&gt; {<br>  event.respondWith(fetchAndApply(event.request))<br>})</p><p>async function fetchAndApply(request) {<br>  const region &#x3D; request.headers.get(‘cf-ipcountry’).toUpperCase()<br>  const ip_address &#x3D; request.headers.get(‘cf-connecting-ip’)<br>  const user_agent &#x3D; request.headers.get(‘user-agent’)</p><p>  let response &#x3D; null<br>  let url &#x3D; new URL(request.url)<br>  let url_hostname &#x3D; url.hostname</p><p>  if (https &#x3D;&#x3D; true) {<br>    url.protocol &#x3D; ‘https:’<br>  } else {<br>    url.protocol &#x3D; ‘http:’<br>  }</p><p>  if (await device_status(user_agent)) {<br>    var upstream_domain &#x3D; upstream<br>  } else {<br>    var upstream_domain &#x3D; upstream_mobile<br>  }</p><p>  url.host &#x3D; upstream_domain<br>  if (url.pathname &#x3D;&#x3D; ‘&#x2F;‘) {<br>    url.pathname &#x3D; upstream_path<br>  } else {<br>    url.pathname &#x3D; upstream_path + url.pathname<br>  }</p><p>  if (blocked_region.includes(region)) {<br>    response &#x3D; new Response(‘Access denied: WorkersProxy is not available in your region yet.’, {<br>      status: 403<br>    })<br>  } else if (blocked_ip_address.includes(ip_address)) {<br>    response &#x3D; new Response(‘Access denied: Your IP address is blocked by WorkersProxy.’, {<br>      status: 403<br>    })<br>  } else {<br>    let method &#x3D; request.method<br>    let request_headers &#x3D; request.headers<br>    let new_request_headers &#x3D; new Headers(request_headers)</p><pre><code class="hljs">new_request_headers.set(&#39;Host&#39;, url.hostname)new_request_headers.set(&#39;Referer&#39;, url.hostname)let original_response = await fetch(url.href, &#123;        method: method,        headers: new_request_headers&#125;)let original_response_clone = original_response.clone()let original_text = nulllet response_headers = original_response.headerslet new_response_headers = new Headers(response_headers)let status = original_response.statusnew_response_headers.set(&#39;access-control-allow-origin&#39;, &#39;*&#39;)new_response_headers.set(&#39;access-control-allow-credentials&#39;, true)new_response_headers.delete(&#39;content-security-policy&#39;)new_response_headers.delete(&#39;content-security-policy-report-only&#39;)new_response_headers.delete(&#39;clear-site-data&#39;)const content_type = new_response_headers.get(&#39;content-type&#39;)if (content_type.includes(&#39;text/html&#39;) &amp;&amp; content_type.includes(&#39;UTF-8&#39;)) &#123;  original_text = await replace_response_text(original_response_clone, upstream_domain, url_hostname)&#125; else &#123;  original_text = original_response_clone.body&#125;response = new Response(original_text, &#123;  status,  headers: new_response_headers&#125;)</code></pre><p>  }<br>  return response<br>}</p><p>async function replace_response_text(response, upstream_domain, host_name) {<br>  let text &#x3D; await response.text()</p><p>  var i, j<br>  for (i in replace_dict) {<br>    j &#x3D; replace_dict[i]</p><pre><code class="hljs">if (i == &#39;$upstream&#39;) &#123;  i = upstream_domain&#125; else if (i == &#39;$custom_domain&#39;) &#123;  i = host_name&#125;if (j == &#39;$upstream&#39;) &#123;  j = upstream_domain&#125; else if (j == &#39;$custom_domain&#39;) &#123;  j = host_name&#125;let re = new RegExp(i, &#39;g&#39;)text = text.replace(re, j)</code></pre><p>  }<br>  return text<br>}</p><p>async function device_status(user_agent_info) {<br>  var agents &#x3D; [“Android”, “iPhone”, “SymbianOS”, “Windows Phone”, “iPad”, “iPod”]<br>  var flag &#x3D; true<br>  for (var v &#x3D; 0; v &lt; agents.length; v++) {<br>    if (user_agent_info.indexOf(agents[v]) &gt; 0) {<br>      flag &#x3D; false<br>      break<br>    }<br>  }<br>  return flag<br>}</p><p>３.回到设置，触发器，绑定自定义域名，，等待DNS解析生效后即可访问<br>注意！如果是使用CloudNS提供的免费域名，不要用来绑定类似于Github这种有关人家版权的网站，会被封号！这是我亲身试验过的！</p><h2 id="待更新》》》"><a href="#待更新》》》" class="headerlink" title="待更新》》》"></a>待更新》》》</h2>]]></content>
    
    
    
    <tags>
      
      <tag>CloudFlare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过Github Pages+Hexo搭建博客教程</title>
    <link href="/2024/01/28/Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <url>/2024/01/28/Pages-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;废话不多说，直接上教程：</p><p>一：环境和工具准备：<br>1.系统：Windows10<br>2.Node js<br>3.Git<br>4.hexo<br>5.文本编辑器（这里推荐Sublime Text）<br>一个Github账号</p><p>二.Node js的安装：<br>1.打开Node官网，下载Node js安装程序，下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a><br>2.下载后安装，安装目录尽量默认，除非你对它非常了解。<br>3.安装完成后，检查是否安装成功。键盘按下Win+R键，打开cmd窗口，输入：node -v，看到了<br>版本信息，代表安装成功。<br>4.修改下载源。npm下载各种模块，默认是从国外的服务器下载，速度较慢，把它换成国内镜像，打开cmd窗口，运行命令：npm config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a></p><p>三.安装Git：<br>1.进入官网：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> ，由于官网下载太慢可以通过淘宝的开源镜像下载 网址：<a href="https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/">https://registry.npmmirror.com/binary.html?path=git-for-windows/v2.36.1.windows.1/</a><br>2.下载后傻瓜式安装即可，安装目录可以默认，可以自选。<br>3.在桌面右键，出现Open Git Bash here即代表安装成功。</p><p>四.安装Hexo：<br>1.右键Git Bash输入如下命令安装：npm install -g hexo-cli<br>2.安装完后输入hexo -v验证，出现版本号即代表成功。</p><p>五.Github与仓库的创建<br>1.进入官网：<a href="https://github.com/">https://github.com/</a><br>2.点击右上角Sign up进行注册：<br>3.填写自己的邮箱、密码、用户名等信息，然后用邮箱验证即可完成。<br>4.注册完成后，点击右上角+按钮，选择New repository，创建一个名称为用户名.github.io<br>的仓库。</p><p>注意：1.名称必须为你的用户名.github.io,不然会404<br>&emsp;&emsp;2.Description：为描述仓库。（选填）<br>&emsp;&emsp;3.勾选 Initialize this repository with a README 初始化一个 README.md文件。<br>&emsp;&emsp;4.点击 Creat repository 进行创建。</p><p>六.环境配置：<br>1.配置用户名和邮箱：<br><code>git config --global user.name &quot;你的用户名&quot; git config --global user.email &quot;你的邮箱&quot;</code><br>2.通过 <code>git config -l</code>检查是否配置成功，现在git安装及配置全部完成。</p><p>七.连接至Github：<br>1.执行以下命令生成ssh公钥，它用于你的计算机连接Github。<br><code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code></p><p>生成之后打开C盘用户文件夹下的.ssh文件夹，有一个名为id_rsa.pub的文件，用记事本打开<br>复制里面所有内容，然后开始在github中配置ssh密钥。</p><p>2.将 SSH KEY 配置到 GitHub<br>进入Github，点击右上角头像，选择settings，进入设置后选择 SSH and GPG keys，<br>名字尽量写英文的，把刚才复制的公钥填到 Key 那一栏。完成后保存。</p><p>3.测试连接，输入以下命令：<br><code>ssh -T git@github.com</code><br>出现连接到账户的提示信息，说明大功告成，现在完成了环境准备工作。</p><p>八.初始化Hexo项目<br>1.在你想放博客文件的路径打开GBH，执行下列命令初始化项目。（把blog后面的东西删掉）<br><code>hexo init blog(项目名)</code><br>2.进入blog文件夹，再次右键GBH，输入 <code>npm i</code>安装相关依赖。</p><p>3.安装完成后，blog文件夹内有如下结构：<br>【node_modules】：依赖包<br>【scaffolds】：生成文章的一些模板<br>【source】：用来存放你的文章<br>【themes】：主题<br>【.npmignore】：发布时忽略的文件（可忽略）<br>【_config.landscape.yml】：主题的配置文件<br>【config.yml】：博客的配置文件<br>【package.json】：项目名称、描述、版本、运行和开发等信息</p><p>4.输入hexo s启动项目</p><p>5.打开浏览器，输入他给出的链接：<a href="http://localhost:4000/">http://localhost:4000/</a><br>看到如下效果代表博客构建成功。<br>！<a href="https://bu.dusays.com/2022/05/26/628e5423df640.webp">博客</a></p><h2 id="九-更换主题（这里我以我使用的Fluid主题为例）-emsp-注：以下步骤摘自Fluid官网：https-github-com-fluid-dev-hexo-theme-fluid1-安装主题进入博客文件夹执行以下命令安装主题：npm-install-save-hexo-theme-fluid然后在博客目录下创建-config-fluid-yml，将主题的-config-yml-内容复制进去。下载链接：https-github-com-fluid-dev-hexo-theme-fluid-blob-master-config-yml-进不去的挂魔法-2-指定主题theme-fluid-指定主题-language-zh-CN-指定语言，会影响主题显示的语言，按需修改3-创建「关于页」：输入如下命令：hexo-new-page-about创建成功后，编辑博客目录下-source-about-index-md，添加-layout-属性。修改完成后的文件示例如下："><a href="#九-更换主题（这里我以我使用的Fluid主题为例）-emsp-注：以下步骤摘自Fluid官网：https-github-com-fluid-dev-hexo-theme-fluid1-安装主题进入博客文件夹执行以下命令安装主题：npm-install-save-hexo-theme-fluid然后在博客目录下创建-config-fluid-yml，将主题的-config-yml-内容复制进去。下载链接：https-github-com-fluid-dev-hexo-theme-fluid-blob-master-config-yml-进不去的挂魔法-2-指定主题theme-fluid-指定主题-language-zh-CN-指定语言，会影响主题显示的语言，按需修改3-创建「关于页」：输入如下命令：hexo-new-page-about创建成功后，编辑博客目录下-source-about-index-md，添加-layout-属性。修改完成后的文件示例如下：" class="headerlink" title="九.更换主题（这里我以我使用的Fluid主题为例）&emsp;注：以下步骤摘自Fluid官网：https://github.com/fluid-dev/hexo-theme-fluid1.安装主题进入博客文件夹执行以下命令安装主题：npm install --save hexo-theme-fluid然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。下载链接：https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml(进不去的挂魔法)2.指定主题theme: fluid  # 指定主题 language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改3.创建「关于页」：输入如下命令：hexo new page about创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。修改完成后的文件示例如下：&#96;"></a>九.更换主题（这里我以我使用的Fluid主题为例）<br>&emsp;注：以下步骤摘自Fluid官网：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a><br>1.安装主题<br>进入博客文件夹执行以下命令安装主题：<br><code>npm install --save hexo-theme-fluid</code><br>然后在博客目录下创建 _config.fluid.yml，将主题的 _config.yml 内容复制进去。<br>下载链接：<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml</a><br>(进不去的挂魔法)<br>2.指定主题<br><code>theme: fluid  # 指定主题 language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改</code><br>3.创建「关于页」：输入如下命令：<br>hexo new page about<br>创建成功后，编辑博客目录下 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。<br>修改完成后的文件示例如下：<br>&#96;</h2><h2 id="title-aboutdate-2024-01-28-15-20-33layout-about"><a href="#title-aboutdate-2024-01-28-15-20-33layout-about" class="headerlink" title="title: aboutdate: 2024-01-28 15:20:33layout: about"></a>title: about<br>date: 2024-01-28 15:20:33<br>layout: about</h2><p>这里写关于页的正文，支持 Markdown, HTML<br>&#96;<br>本地启动项目:<br>输入命令：hexo g -d<br>&emsp;hexo s</p><p>浏览器输入：<a href="http://localhost:4000，">http://localhost:4000，</a><br>即可看到Fluid主题页面</p><p>十.页面个性化</p><ol><li>浏览器tab页名称<br>修改根目录下 _config.yml 中的 title 字段。<br>subtitle为副标题<br>description不用填写<br>keywords关键词，可不填写<br>author博客所有者<br>language语言，中国大陆使用zh-CN<br>timezone不用填写</li></ol><p>2.博客导航栏左侧文字<br>blog目录下_config.fluid.yml中的blog_title 字段。</p><p>3.首页正中间的文字<br>blog目录下_config.fluid.yml中的text字段。</p><p>如果想使用一言，需打开主题的打字机功能，修改好后如下所示</p><h1 id="一些好玩的功能"><a href="#一些好玩的功能" class="headerlink" title="一些好玩的功能"></a>一些好玩的功能</h1><h1 id="Some-fun-features"><a href="#Some-fun-features" class="headerlink" title="Some fun features"></a>Some fun features</h1><p>fun_features:</p><h1 id="为-subtitle-添加打字机效果"><a href="#为-subtitle-添加打字机效果" class="headerlink" title="为 subtitle 添加打字机效果"></a>为 subtitle 添加打字机效果</h1><h1 id="Typing-animation-for-subtitle"><a href="#Typing-animation-for-subtitle" class="headerlink" title="Typing animation for subtitle"></a>Typing animation for subtitle</h1><p>  typing:<br>    enable: true</p><pre><code class="hljs">然后添加一言，修改好后如下所示：`# 通过 API 接口作为首页副标题的内容，必须返回的是 JSON 格式，如果请求失败则按 text 字段显示，该功能必须先开启 typing 打字机功能# Subtitle of the homepage through the API, must be returned a JSON. If the request fails, it will be displayed in `text` value. This feature must first enable the typing animationapi:  enable: true  # 请求地址  # Request url  url: &quot;https://v1.hitokoto.cn/&quot;  # 请求方法  # Request method  # Available: GET | POST | PUT  method: &quot;GET&quot;  # 请求头  # Request headers  headers: &#123;&#125;  # 从请求结果获取字符串的取值字段，最终必须是一个字符串，例如返回结果为 &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, 则取值字段为 [&#39;data&#39;, &#39;content&#39;]；如果返回是列表则自动选择第一项  # The value field of the string obtained from the response. For example, the response content is &#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;fluid&quot;, &quot;content&quot;: &quot;An elegant theme&quot;&#125;&#125;, the expected `keys: [&#39;data&#39;,&#39;content&#39;]`; if the return is a list, the first item is automatically selected  keys: [&quot;hitokoto&quot;]`</code></pre><p>至此，一言添加完毕。</p><p>十一.将静态博客挂载到Github Pages<br>方法一：<br>1.安装 hexo-deployer-git，输入以下命令：<br><code>npm install hexo-deployer-git --save</code><br>2.修改根目录下的 _config.yml，配置 GitHub 相关信息</p><p>deploy:<br>  type: git<br>  repository: <a href="https://github.com/XXX/XXX.github.io.git">https://github.com/XXX/XXX.github.io.git</a><br>  branch: main<br>  token: XXXXXXXXXXXXX</p><p>  repository获取方式为：<br>  进入<a href="https://github.com/">https://github.com/</a>,<br>  点击右上角三条杠，点击你新建的用户名.github.io的仓库<br>  点击中间那个绿色的Code按钮，选择左边的 Local 下面三个选项里选SSH,复制那个链接即可</p><p>  其中 token 为 GitHub 的 Personal access tokens，获取方式如下图：<br>  token只会出现一次，复制下来妥善保存，如果丢失，则要重新生成。</p><p>  ！<a href="https://img-blog.csdnimg.cn/2350558a10d94c8ab4959b04771d2bcc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70">token</a></p><p>&emsp;部署到Github：<br>先输入hexo clean清除缓存<br>再输入命令hexo g -d<br>部署完成后等待两分钟，浏览器访问：https:&#x2F;&#x2F;你的GitHub用户名.github.io<br>能正常访问即部署成功。<br>方法二：直接将blog文件夹内 public 目录中的文件和目录推送至 GitHub 仓库和分支中。（不推荐）</p><p>十二.连接不到Github的解决方法：</p><p>注意：当你在与Github进行ssh通信时候出现超时或者是连接被关闭的情况，可以尝试以下解决方案。</p><p>1.挂代理和换网络<br>2.开源项目Github520<br>通过修改Host文件的方法解决访问速度慢的问题（地址：<a href="https://github.com/521xueweihan/GitHub520%EF%BC%89">https://github.com/521xueweihan/GitHub520）</a><br>3.连接有效性检验：ssh -T <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;">&#x67;&#105;&#116;&#x40;&#103;&#x69;&#116;&#x68;&#117;&#98;&#46;&#x63;&#x6f;&#x6d;</a></p><p>&emsp;结语：到这里，使用Github Pages+Hexo搭建博客的教程结束，明天更新主题的优化和改造，有什么不懂的可以在下面留言，回复的话应该到明天了，明天见！</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo博客教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇文章</title>
    <link href="/2024/01/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>/2024/01/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>&emsp;&emsp;这是我的第一篇文章，想了半天也不知道写什么好，所以，就当是胡说八道吧！</p><p>&emsp;&emsp;我是一个初中牲，平时喜欢听听歌，看看动漫，不是很喜欢体育运动，偶尔闲着没事还会敲敲代码，在电脑上码码字。</p><p>&emsp;&emsp;大概两周前我们放了寒假，回来以后就无所事事，每天脑子空空的，除了吃就是睡<br>，就这么浑浑噩噩过了5天多，我突然热血沸腾，想着不能虚度光阴，写作业是肯定不可能的，于是我就想起了做一个博客，当时头脑一热，开始在网上去搜索各种教程，从国内到国外，从B站到YouTube，从CSDN到博客园；这么折腾了快一周，前前后后试了Vercel，Replit，雨云，GoogleCloud等等差不多六七种方案。</p><p>&emsp;&emsp;为了找教程，我甚至去霍格沃茨修习了一身魔法，就这么一顿折腾，最后我终于，找到了一种堪称完美的方法：Github Pages+Hexo！世界上最大编程社区加上轻量化的博客框<br>架，既不用自己买服务器，也不用自己花钱买域名。只要Github不倒闭，我的网站就不会倒闭，实在是一举两得，一石二鸟啊！</p><p>&emsp;&emsp;有人想要教程吗？下次出吧，加油！有问题请留言，谢谢客官！</p><p>&emsp;&emsp;提前祝你们新年快乐吧，嘿嘿！</p>]]></content>
    
    
    
    <tags>
      
      <tag>第一</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/01/23/hello-world/"/>
    <url>/2024/01/23/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
